

## 目录
- [编程范式](#编程范式)
- [机器/汇编/高级语言](#机器汇编高级语言)
- [进制表示](#进制表示)
- [值类别与运算符优先级](#值类别与运算符优先级)
- [格式化输出与 ASCII](#格式化输出与-ascii)
- [强制类型转换](#强制类型转换)
- [printf("%*c") 的用法](#printf%c-的用法)
- [C++ `std::string` 与 `sizeof`](#c-stdstring-与-sizeof)
- [循环与退出](#循环与退出)
- [构造数据类型](#构造数据类型)
- [面向对象/面向过程](#面向对象面向过程)
- [关于数组大小和 '\\0' 终止符](#关于数组大小和-0-终止符)
- [EOF](#eof)
- [switch](#switch)
- [整体概念：编译与链接](#整体概念编译与链接)
- [inline 作用机制](#inline-作用机制)
- [存储类别与内存区域](#存储类别与内存区域)
- [函数调用的开销](#函数调用的开销)

## 编程范式

什么是命令式编程，什么是函数式编程？

命令式编程时大部分指令都已写好，我可以去按部就班的编译。有函数，那也只是不同参数的传递。template<\class\>看似是传递，但你后续typeT怎样的都已经写好了。

而函数式编程是另一个层面，函数是第一等公民。

比如我有一个鼠标操控电脑，其实 alt+tab 切换 app 后，鼠标对应的操作完全不同，可以是笔可以是准心。对于左键右键都是不一样的。这个时候其实就是把整个鼠标函数作为主体在各个 app 中去传递，app 怎么用完全就不管了。

*注：C++ 模板应写作 `template<class T>`（原文中的 `template<\class\>` 为笔误）。*

***

## 机器/汇编/高级语言

(1) 机器语言

计算机的指令系统称为机器语言，所有的计算机都只能直接执行用机器语言编写的程序。机器语言与计算机的硬件密切相关，机器语言中的计算机指令用二进制形式的代码表示，由若干位 1 和 0 组成。通常，一条计算机指令只能指示计算机完成一个最基本的操作。例如，将某个地址中的内容读入某个寄存器，某寄存器的内容加上另一寄存器的内容，将某寄存器的内容存入某地址等。

(2) 汇编语言

由于计算机的机器语言很难被人理解和阅读，因此人们用类似英语单词缩写的符号指令代替机器语言的二进制代码指令。汇编语言就是用有助于记忆的符号表示计算机机器指令的程序设计语言。例如，取数指令“LD GR0,X”表示从对应变量 X 的内存中取数到寄存器 GR0。加指令“ADD GR0,GR1”将寄存器 GR1 中的内容与寄存器 GR0 中的内容相加，并把结果存于寄存器 GR0 中。存数指令“ST GR0,X”将寄存器 GR0 中的内容存入与变量 X 对应的内存中。

用汇编语言编写的程序要在计算机上执行，应先将用汇编语言编写的程序（称为源程序）转换成机器语言程序，完成这个转换功能的程序称为“汇编器”或“汇编程序”。

（引自《C语言程序设计（第三版）》）

(3) 高级语言

高级语言主要由语句构成，有一定书写规则，程序员用语句表达要计算机完成的操作。与汇编语言相比，高级语言有统一的语法，独立于具体机器，便于人们编码、阅读和理解。

用高级语言编写的源程序要在计算机上执行，也要先将源程序转换成机器语言程序。把用高级语言编写的源程序转换成机器语言程序的翻译程序称为“编译器”或“编译程序”。高级语言是一种既能方便地描述客观对象，又能借助于编译器为计算机所接受、理解和执行的人工语言。例如，用于科学计算的 FORTRAN 语言，早期非常普及的 BASIC 语言，第一个用严格的文法描述的 ALGOL60 语言，便于编写结构化程序的 Pascal 语言以及本书讲述的 C 语言都是高级语言。

问题 6：什么是面向过程语言？

高级语言又可分为面向过程语言和面向问题语言两类。面向过程语言虽然可以独立于计算机编写程序，但用这类语言编写程序时，程序要非常详细地告诉计算机如何做，程序需要详细描述解题的过程和细节。C 语言就是一种面向过程的语言。例如，在某个职工数据文件中查找工号为 22650 的职工，面向过程语言需要详细描述查找过程。以下算法是适应面向过程语言的一个查找过程的描述。

1) 打开职工文件。
2) 当文件未结束时重复执行以下工作：
   a. 读取文件的当前记录。
   b. 如果当前记录中的工号是 22650，则结束步骤 2。
3) 关闭职工文件。
4) 如果找到，则返回找到的职工信息，否则返回找不到的标志信息。

其中，步骤 2 是一个循环控制结构，控制记录一个一个地读取和比较。

问题 7：什么是面向问题语言？

面向问题语言通常是指在特定应用领域中使用的高级语言。人们使用面向问题语言时，不要详细给出问题的求解算法和求解过程，只须指出问题做什么、数据输入和输出形式，就能得到所需的计算结果。实际上，计算机是根据预先的规定，执行先前准备好的程序，回答问题的结果。面向问题语言又称非过程化语言或陈述性语言，如报表语言、SQL（Structured Query Language）等。SQL 是数据库查询语言，在数据库管理系统的支持下，用 SQL 提出的查询或操纵要求，就能由数据库管理系统完成。使用面向问题语言解题时，只要告诉计算机做什么，不必告诉计算机如何做，能方便用户使用和提高程序的开发速度。但实现面向问题语言的系统从最一般的意义下实现问题如何做，通常实现的效率较低。另外，面向问题语言要求问题已有确定的求解方法，目前其应用范围还比较狭窄。

如果用面向问题语言 SQL 描述问题 6 中所述的查找要求，只需要用一条能表达以下含义的简单命令：从职工数据文件选取信息，条件是工号等于 22650。数据文件打开、用循环控制结构描述记录逐个地读取和比较，以及数据文件使用结束的关闭等细节都不再详述。

问题 8：什么是面向对象语言？

为克服面向过程语言过分强调求解过程的细节、程序不易复用等缺点，推出了面向对象程序设计方法和面向对象程序设计语言。面向对象语言引入了对象、消息、类、继承、封装、抽象、多态性等概念和机制。用面向对象语言进行程序设计时，以问题域中的对象为基础，将具有类似性质的对象抽象成类，并利用继承机制，仅对差异进行程序设计。对于大型程序，面向对象语言能提高程序的开发效率、提高程序的可靠性及可维护性等。

*注：面向对象与“解释型”并无必然关系；如 C++/Java（JIT 亦可编译）等均可编译执行。*

***

## 进制表示

| 进制 | 前缀 | 示例 | 对应的十进制值 |
|------|------|------|----------------|
| 二进制 | 0b 或 0B | 0b1010 | 10 |
| 八进制 | 0 | 012 | 10 |
| 十进制 | 无 | 10 | 10 |
| 十六进制 | 0x 或 0X | 0xA | 10 |

***

## 值类别与运算符优先级

> 左值：特定的有地址的变量
>
> 右值：右值通常是“临时”的、没有名字的、即将被销毁的值，我们不能对它取地址。

[运算符优先级与结合性（Microsoft Learn）](https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170)

- 后缀递增与后缀递减属于第 2 组优先级，从左到右关联。
- 前缀递增与前缀递减属于第 3 组优先级，从右到左关联。
- `* / %` 属于第 5 组优先级；`+ -` 属于第 6 组优先级，皆为从左到右关联。

示例：

```
a*a++  // 先执行（a++）语句返回 4，但将 a 左值递增至 5；再执行 *，得到 5*4=20
c=++a+a // 先执行（++a）语句，a 左值递增至 6，并返回 6，再执行 +，得到 6+6=12
```

*注：在 C/C++ 中，`a*a++`、`++a + a` 等表达式存在未序列化的读写，属于未定义行为（结果不可靠）。请避免编写此类代码。*

***

## 格式化输出与 ASCII

```c
printf("%c对应的ASCII码为%d\n", ch, ch);
```

// `%d` 对应数字，`%c` 输出对应字符；`%c`、`%d` 类似于占位符，提前说明这里如何输出并从后找。

***

## 强制类型转换

```c
float n, m;
int _n, _m;
_n = (int)n; _m = (int)m;
```

类型转化 `(int)(x)`。

***

计算机的进制主要包括：二进制（binary）、八进制（octal）、十进制（decimal）和十六进制（hexadecimal）。

```c
printf(" 十进制 %d 对应的八进制数是:%o\n", x, x);
printf(" 十进制 %d 对应的十六进制数是:%x\n", x, x);
```

- `%+5d` 右对齐输出 5 个字符宽度，不足前补空格（当 5 改成 2 时，仍然会输出正常的 168）。
- `%-5d` 左对齐输出 5 个字符宽度，不足后补空格。
- `%+6.2f` 输出 6 个字符宽度（其中 2 位小数），注意正负号占宽度，当 6 改为 1 后也会正常输出整数部分。
- `%E` 输出科学计数法。

注：

```c
scanf("%*d");
```

*注：`%*d` 表示读取但丢弃该整数，不应再传入参数（原文中 `scanf("%*d", &k)` 为错误用法）。*

```c
int a = 168;
float b = 123.456;
float x = 35.567, y;
/*
%5d 右对齐输出 5 个字符宽度，不足前补空格（当 5 改成 2 时，仍然会输出正常的 168）
%-5d 左对齐输出 5 个字符宽度，不足后补空格
%+6.2f 输出 6 个字符宽度（其中 2 位小数）
%E 输出科学计数法
*/
printf(" a = %5d\n", a);
printf(" a = %-5d\n", a);
printf(" b = %6.2f\n", b); // %.2f 形式控制小数精度
printf(" b = %E\n", b);
y = (int)(x*100 + 0.5) / 100.0;
printf(" y = %f\n", y);
```

***

```c
int x; double y;
x = y = 3.5;
```

最终 `x=3, y=3.5`（自动截断转换）。

***

> `if (语句1 && 语句2)` // 如果语句 1 为假，那么语句 2 不会执行。

逗号运算：

```c
int y = 7;
float z = 4;
x = (y = y + 6, y / z);
// 结果 x = 3（按最后的子表达式结果赋值）
```

运算过程中：

- `char -> int`
- `float -> double`

运算对象不同类时，short $\rhd$ unsigned $\rhd$ long $\rhd$ float

***

```c
#include <stdio.h>
int main() {
    int i; char c; long k; float f; double x;
    // i=2,c='B',k=123456,f=5.8,x=3.4;
    /*
    input：
    i=2 c=B
    k=123456
    f=5.8 x=3.4
    */
    scanf("i=%d c=%c", &i, &c);
    getchar();
    scanf("k=%ld", &k);
    getchar();
    scanf("f=%f x=%lf", &f, &x);
    printf("i=%d c=%c k=%ld f=%f x=%lf", i, c, k, f, x);
    return 0;
}
```

> scanf 为格式化输入，会按照双引号内的格式去匹配输入的字符串。它不在意 `"i=%d c=%c"` 间的空格数量，但很在意其他字符匹配，以及两个 scanf 间是否有空格。从本质上讲，我们从键盘输入的数据并没有直接交给 scanf()，而是放入了缓冲区中，直到我们按下回车键（输入换行符），scanf() 才到缓冲区中读取数据。如果缓冲区中的数据符合 scanf() 的要求，那么就读取结束；如果不符合要求，那么就继续等待用户输入，或者干脆读取失败。所以这里要用 getchar() 读掉换行符/空格。

***

```c
#include <stdio.h>
int main() {
    int a = 8, b = 9; float x = 127.895, y = -123.456; char c = 'B'; long n = 12345678L; unsigned u = 65535u;
    printf("%f,%f\n", x, y);            // 输出 float x y
    printf("%-12f,%-12f\n", x, y);      // 左对齐  共宽 12
    // 由于二进制小数精度问题，所以有误差
    // 127.894997  ,-123.456001
    printf("%8.3f,%8.3f,%.3f,%.3f,%4f,%5f\n", x, y, x, y, x, y); // 负号占用一格
    // 127.895,-123.456,127.895,-123.456,127.894997,-123.456001
    printf("%s,%6.3s,%-10.5s\n", "c language", "c language", "c language"); // %s 输出字符串，%6.3s 表示总宽 6，取前 3 个字符
    // c language,   c l, c lan
    return 0;
}
```

> 基本的，正整数对应右对齐，负整数对应左对齐，数字大小为输出宽度。值得注意的是，小数都是二进制小数表示，所以除非明确精度或者恰好比较好表示，则都会出现“≠”的情况。另外，字符串 `.x` 类似于“取小数”，即取前 x 个字符。

***

自顶向下，逐步细化；模块化编程；结构化编码。

- 不能互相耦合。

***

exit app 级的退出。

***

C++ 数据和它的属性打包了，想怎么写怎么写。C 语言：数据属性/变量要在一开头就全定义完毕（早期？）

```
// 必须定义在作用域开头：在 C89/C90 标准中，变量必须在代码块（如函数、循环、条件语句）的开头定义。例如：

void example() {
    int a = 10; // 正确：定义在函数开头
    printf("%d", a);
    // 错误：不能在语句后定义新变量
    printf("Hello");
    int b = 20; // 编译错误（C89/C90）
}
// 历史原因：早期编译器设计简单，变量定义需集中处理内存分配。这种限制也源于 C 语言的“声明在前”传统（如函数原型需在调用前声明）。
```

*注：自 C99 起，C 已允许“声明与语句交错”（可在块内任意处定义变量）。*

***

## switch

switch 接口加速？执行列表，列表要跳？

```c
switch (expression) {
    case 常量表达式1:    [break];
    case 常量表达式2:    [break];
    [default: ;]
}
```

```c
// switch_statement1.cpp
#include <stdio.h>

int main() {
   const char *buffer = "Any character stream";
   int uppercase_A, lowercase_a, other;
   char c;
   uppercase_A = lowercase_a = other = 0;

   while ( (c = *buffer++) ) {   // Walks buffer until NULL
      switch ( c ) {
         case 'A':
            uppercase_A++; // 不 break，跳转，会继续执行下一个 case，包括 default
            break;
         case 'a':
            lowercase_a++;
            break;
         default:
            other++;
      }
   }
   printf("\nUppercase A: %d\nLowercase a: %d\nTotal: %d\n",
      uppercase_A, lowercase_a, (uppercase_A + lowercase_a + other));
}
```

*注：编译器可能将密集的 switch 分支优化为“跳转表”，从而加速分派。`printf_s` 为 MSVC 扩展，Linux 上可改用 `printf`。*

***

## printf("%*c") 的用法

这是 C/C++ 中一个特殊的格式化输出方式。`printf("%*c", width, character)` 中的 `%*c` 是一个格式说明符，它允许你通过参数动态指定字段宽度。

说明：

- `%*c`：`*` 表示字段宽度由参数指定，`c` 表示输出一个字符。
- 第一个参数是宽度值（整数），第二个参数是要输出的字符。

示例代码：

```c
#include <stdio.h>

int main() {
    int j;
    scanf("%d", &j);
    for (int i = 0; i < 40; ++i) printf("%d", i);
    printf("\n");
    // 输出字符 'A'，并指定字段宽度为 10
    printf("%*c\n", 10, 'A');
    // 输出字符 'B'，并指定字段宽度为 5
    printf("%*c\n", 5, 'B');
    // 输出字符 'X'，并指定字段宽度为 1（实际上就是普通输出）
    printf("%*c\n", 1, 'X');
    printf("j=%5d\n", j);
    /*
    %*c 格式说明符：
    %c 是输出单个字符的格式说明符
    * 表示字段宽度由参数指定
    所以 %*c 的含义是：输出一个字符，但该字符占据的宽度由参数指定
    所以之后会增加一个参数
    */
    printf("%*c", j, ' ');
    printf("end");
    return 0;
}
```

***

## C++ `std::string` 与 `sizeof`

让我来解释一下你提出的两个问题：

#### 1. 为什么 `sizeof(s)` 总是输出 8？

`sizeof(s)` 返回的是 `std::string` 对象本身的大小，而不是字符串内容的长度。在大多数现代系统上，`std::string` 对象内部通常包含以下成员：

- 指向实际字符串数据的指针（在 64 位系统上通常占 8 字节）
- 字符串长度信息
- 字符串容量信息

所以 `sizeof(s)` 返回的是这个 string 对象结构体的大小，通常是 8 字节（在 64 位系统上）或 4 字节（在 32 位系统上），与实际存储的字符串内容长度无关。

如果你想要获取字符串的实际长度，应该使用 `s.length()` 或 `s.size()` 方法：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    cin >> s;
    cout << "sizeof(s) = " << sizeof(s) << endl;     // string 对象的大小
    cout << "s.length() = " << s.length() << endl;   // 字符串内容的实际长度
    return 0;
}
```

*注：`std::string` 的对象大小完全“依实现而定”。在常见的 GCC/libstdc++ 64 位环境下通常为 24 字节或更多，并非固定为 8 字节。*

#### 2. `printf` 中的 `0.2` 是什么含义？

在格式化字符串 `"%0.2f"` 中：

- `0` 表示用 0 来填充字段宽度（如果不指定宽度则无效果）。
- `.2` 表示小数点后保留 2 位小数。
- `f` 表示这是一个浮点数。

所以 `%0.2f` 的意思是：输出一个浮点数，保留 2 位小数，不足的位数用 0 填充。

但要注意，在你的例子中，格式是 `"%0.2f"`，但没有指定总宽度，所以 `0` 实际上没有效果。如果你想要看到用 0 填充的效果，需要指定总宽度，比如 `"%08.2f"`：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    float f = 12.3f;
    printf("默认格式: %.2f\n", f);       // 输出: 12.30
    printf("0填充格式: %08.2f\n", f);    // 输出: 00012.30
    printf("空格填充格式: %8.2f\n", f);  // 输出:    12.30 (前面有空格)
    return 0;
}
```

在你的代码中，`%0.2f` 实际上等同于 `%.2f`，都是保留两位小数的意思。

***

## 循环与退出

- for 顶测试
- do while 底测试

`exit(0)` $\leftrightarrow$ `exit(EXIT_SUCCESS)`

***

## 构造数据类型

数组，指针，结构，联合。

***

## 面向对象/面向过程

面向对象是解释性的，可以临时定义变量分配内存。

面向过程，整个函数是一个对象，必须要在开头把变量定义以分配内存。

*注：是否“解释”与是否“面向对象”无关；此外，现代 C（C99 起）允许在块内任意位置定义变量。*

***

常量存储空间永远不会被更改。

***

```c
int i = 1;
printf("%d %d", ++i, --i);
```

是什么东西，执行顺序？看编译器。

*注：上述写法对同一标量在一个表达式内多次读写，属于未定义行为；请不要依赖其顺序或结果。*

***

`*` 与 `&` 究竟是什么。

***

## 关于数组大小和 '\\0' 终止符

你问到两个重要问题：

为什么数组大小没有填？

这是 C/C++ 的特性：当你用字符串字面量初始化字符数组时，编译器会自动计算所需的数组大小，这样做既方便又安全，避免了手动计算可能出现的错误。

最后一个元素会是 '\\0' 吗？

是的，当你用双引号括起来的字符串字面量初始化字符数组时，编译器会自动在末尾添加 '\\0' 终止符。所以 `char str[] = "hello world";` 实际存储的是 `{'h','e','l','l','o',' ','w','o','r','l','d','\\0'}`。这使得该数组可以被所有期望以 '\\0' 结尾的 C 风格字符串函数正确处理，如 `strlen()`, `strcpy()` 等。

***

## EOF

EOF  endofile

是个字符。

```c
while (getchar() != EOF) {
    // 读一个字符，如果读到文件末尾，则返回 EOF
}
```

ctrl+z 结束。

*注：EOF 代表“end of file”，在 C 中是一个整型常量宏（通常为 -1），不是字符。终端中触发 EOF：Linux/Unix 为 Ctrl+D，Windows 为 Ctrl+Z。*

***

转向语句是编程语言中直接改变程序执行顺序的结构化指令，主要通过选择结构和循环结构实现流程控制。在 C 等现代编程语言中，if-else 语句通过条件表达式实现程序分支跳转，switch-case 语句配合 break 命令完成多分支转向。循环结构中的 continue 与 break 语句可分别实现循环体内部跳转和循环终止。

转向语句非常的慢。比较符本质还是运算，顺序运行也很快。

*注：分支是否“慢”取决于分支预测与局部性，不能一概而论。*

***

## C++ 并行计算？

线程互相独立，沟通起来很困难。进程。

***

## 整体概念：编译与链接

C/C++ 的构建通常分两步：

1. 编译：每个源文件 → 目标文件（.o）
2. 链接：把所有目标文件（+ 库）→ 可执行文件（或共享库）

### 编译阶段（逐源文件）

流程：预处理 → 编译成汇编 → 汇编成目标文件。

产物：可重定位的目标文件（.o），包含机器码、符号表、重定位信息。

作用范围：只检查单个翻译单元内的语法/语义（不知道其他文件是否提供缺失函数）。

常用命令：

### 链接阶段（全程序）

工作：合并目标文件，解析符号引用（谁定义了 foo、谁需要 foo），执行重定位，生成可执行文件或 .so/.dll。

输入：.o 文件 + 库（.a 静态库，.so 共享库），注意库的搜索顺序与链接次序。

常用命令：

*注：链接器决定二进制的静态布局（节、符号、相对地址等）；最终装载到内存的实际基址由操作系统/加载器决定，启用 PIE/ASLR 时每次运行都可能不同。*

```c
/* add.c */        int add(int a,int b){ return a+b; }
/* add.h */        int add(int a,int b);
/* main.c */       #include "add.h"
                   int main(){ return add(2,3); }
```

***

## inline 作用机制

编译期内联：编译器把函数体直接“展开”到调用点，消除函数调用/返回的固定开销（入栈/出栈、保存/恢复寄存器、参数传递）。

跨边界优化：展开后，编译器能在更大的基本块上继续做优化（常量传播、死代码消除、公共子表达式、循环不变代码外提、向量化、分支预测改写），这通常比纯粹省“call”更值钱。

链接期内联（LTO）：开启 LTO 时，链接器阶段会用编译器的中间表示做“全程序优化”，可在不同源文件间继续内联与跨模块优化（去死代码、去重复、跨 TU 常量传播、去虚拟化等）。

两阶段提速点：

- 编译阶段（每个源文件内）
  - 消除调用开销：去掉 prologue/epilogue、参数栈传递。
  - 曝露上下文：能把小函数与调用点合并，启用更激进的局部优化。
  - 受限于“翻译单元”：默认只能对同一源文件看见的定义做内联。
- 链接阶段（全程序，需 LTO）
  - 跨文件内联：把多个 .o 的 IR 合并后继续内联，突破单 TU 限制。
  - 全局裁剪：移除未用函数、合并重复模板/内联体，整体瘦身或重排，提升 i-cache 局部性。
  - 更深入的跨模块优化：内联后触发进一步的全程序常量折叠、分支消除。

语义与关键字：

- C++ 的 inline：语义上允许“在多个翻译单元提供相同定义”（ODR 规则），方便把小函数放到头文件；是否真的内联由优化器决定，不保证。
- C 的 inline（C99）更复杂：头文件里推荐用 `static inline` 定义小函数，避免外部链接冲突；`extern inline`/裸 `inline` 各编译器行为有差异，按规范谨慎使用。
- 宏 vs inline：宏是纯文本替换，无类型检查；inline 是函数，类型安全、可调试，优化器也更聪明。

何时更快：

- 很小、调用频繁、在热循环里的函数（如 `min/max`/访问器/位操作）收益明显。
- 内联能触发后续优化（如把参数是常量时整段代码折叠掉）。
- 与模板/泛型结合的短函数（STL 迭代器/算法）常被充分内联。

何时可能更慢：

- 代码膨胀：大量内联使二进制变大，指令缓存命中率下降，反而变慢。
- 链接/编译时间：开启大量内联/LTO 会增加构建时间与内存占用。
- 大函数内联：收益不及代价，优化器通常会拒绝（除非强制）。

实用建议：

- 写法：头文件里的小函数，C++ 用 inline；C 用 static inline。
- 不强制：除非明确知道要强制，否则别用 `always_inline`；让优化器决策。
- 编译参数：常规内联 `-O2` 或 `-O3`。跨文件内联（LTO）：编译与链接都加 `-flto`。
- 观察内联决策：`-Winline`（对被标记 inline 却未内联给出提示），或用 `-fverbose-asm`/`objdump -d` 看汇编。
- 选择性控制：禁止/限制 `-fno-inline`、`-fno-inline-functions-called-once`；强制（慎用）`__attribute__((always_inline))`/`[[gnu::always_inline]]`（需与 `-O` 配合）。

一句话总结：

“inline”加速的核心不是“省一次 call”这么简单，而是“把调用点与被调函数融合，让优化器在更大范围上做更强的优化”；常规内联发生在编译期，同一源文件内；配合 LTO 则可在链接期跨文件继续内联与全程序优化。合理使用（小而热的函数 + 合理优化级别 + LTO）通常带来可观收益，但要警惕代码膨胀与构建时间上升。需要的话我可以把你的 VS Code 构建任务加上 `-O3 -flto` 版本，做一次对比构建和体感测试。

***

## 存储类别与内存区域

其中，程序代码存放在程序区，一般由操作系统控制；程序中运行的中间结果和最终结果数据存放在静态存储区或动态存储区。

**静态存储方式**：是指在程序运行期间分配固定的存储空间的方式。全局变量、静态变量和字符串常量的存储就采用这种方式。

在程序开始时给全局变量分配存储单元，程序执行完毕才释放。也就是说，在程序执行过程中，全局变量占据固定的存储单元，而不是动态地进行分配和释放。对于静态变量，不管是全局变量还是局部变量，在整个程序执行期间都不释放所占的存储空间。

**动态存储方式**：是指在程序运行期间根据需要进行动态的分配存储空间的方式。形参、自动变量（auto）、函数调用时的现场保护和返回地址等的存储就采用这种方式。由于是动态分配存储单元，且使用完立即释放，所以，如果在一个程序中两次调用同一个函数，分配给函数中局部变量等数据的存储空间地址可能是不相同的。在 C 语言中，每一个变量和函数具有两个属性：数据类型和数据的存储类别。在前面的章节中，定义变量时，形式上只是声明变量的数据类型。作为定义变量的完全形式，还应该包括存储类别。

> register：动作极快，但是找不到地址。

Got it. Here’s a concise, practical rundown of C/C++ 的 register 特性和“能用几个”的问题。

是什么：

语义：对编译器的“建议”把变量放入 CPU 寄存器以加速访问（减少内存读写）。现代现实：几乎所有现代编译器都会忽略这个建议，由寄存器分配器根据优化策略自动决定；写与不写通常无差别。

限制与规则：

- 作用域/存储期：与 auto 一样是块作用域、自动存储期（进入块创建，离开块销毁）。
- 取地址：不能对 register 变量取地址（`&x` 非法），因为寄存器没有内存地址这一抽象。
- 位置：不能用于文件作用域（全局变量），只能用于块内或函数形参。
- 组合：不能与 static 同时使用。
- 数组/大对象：即使写成 `register int a[100];`，编译器也不会把整个数组放进寄存器（寄存器太小），最多对标量临时值做寄存器分配。

能用几个 register？

语言层面没有固定上限，真正的上限由“硬件可用寄存器数 + 编译器的寄存器分配算法 + 活跃生命周期冲突”决定。历史上某些老编译器可能只“尊重”前几个 register 声明；现代编译器通常直接忽略关键字，由优化器全局决策。结论：写再多 register 也不会让你“超额”占用寄存器；能用多少由编译器和硬件决定，而不是由关键字数量决定。

与 C++/标准演进：

- C：register 仍存在，但基本无实际优化意义（C23 标准已删除，GCC/Clang 多为兼容保留）。
- C++：自 C++11 起废弃，C++17 开始移除其语义（多数编译器视为“无效果”的关键字或给出弃用警告）。

实践建议（更有效的提速方式）：

- 打开优化选项：`-O2` 或 `-O3`（GCC/Clang），这是决定寄存器使用的关键。
- 让编译器更易优化：合理拆分热循环、小函数 inline、`restrict`（C）指针、消除别名、避免不必要的易变访问等。
- 对性能敏感片段，用基准测试 + 查看汇编（`objdump -d` 或 `-S -fverbose-asm`）验证寄存器分配是否达标。

***

## 函数调用的开销

- 调用/返回指令：执行 call/ret 或等价序列；涉及返回地址入栈/出栈、分支预测（返回栈预测器）。预测正确时开销很小，预测失败代价明显。
// 以上为函数调用的主要开销点汇总。
