

/*
期中考试会差不多到数组
还是要熟练掌握课本
期中考试≈3次作业

*/
<p>
什么是命令式编程，什么是函数式编程？
命令式编程时大部分指令都已写好，我可以去按部就班的编译。有函数，那也只是不同参数的传递。template<\class\>看似是传递，但你后续typeT怎样的都已经写好了

而函数式编程是另一个层面，函数是第一等公民。
比如我有一个鼠标操控电脑，其实alttab切换app后，鼠标对应的操作完全不同，可以是笔可以是准心。对于左键右键都是不一样的。这个时候其实就是把整个鼠标函数作为主体在各个app中去传递，app
怎么用完全就不管了。
<p>


***
<p>

(1)机器语言
计算机的指令系统称为机器语言，所有的计算机都只能直接执行用机器语言编写的程序。机器
语言与计算机的硬件密切相关，机器语言中的计算机指令用二进制形式的代码表示，由若干位1和
0组成。通常，一条计算机指令只能指示计算机完成一个最基本的操作。例如，将某个地址中的内
容读入某个寄存器，某寄存器的内容加上另一寄存器的内容，将某寄存器的内容存入某地址等。

(2)汇编语言
由于计算机的机器语言很难被人理解和阅读，因此人们用类似英语单词缩写的符号指令代替
机器语言的二进制代码指令。汇编语言就是用有助于记忆的符号表示计算机机器指令的程序设计
语言。例如，取数指令“LD GR0,X”表示从对应变量X的内存中取数到寄存器GRO。加指令“ADD
GRO,GR1”将寄存器GR1中的内容与寄存器GRO中的内容相加，并把结果存于寄存器GRO中。
存数指令“ST GRO,X”将寄存器GRO中的内容存入与变量X对应的内存中。
用汇编语言编写的程序要在计算机上执行，应先将用汇编语言编写的程序(称为源程序)转
换成机器语言程序，完成这个转换功能的程序称为“汇编器”或“汇编程序”。
C语言程序设计(第三版) 

(3)高级语言
高级语言主要由语句构成，有一定书写规则，程序员用语句表达要计算机完成的操作。与汇
编语言相比，高级语言有统一的语法，独立于具体机器，便于人们编码、阅读和理解。
用高级语言编写的源程序要在计算机上执行，也要先将源程序转换成机器语言程序。把用高
级语言编写的源程序转换成机器语言程序的翻译程序称为“编译器”或“编译程序”。
高级语言是一种既能方便地描述客观对象，又能借助于编译器为计算机所接受、理解和执行
的人工语言。例如，用于科学计算的FORTRAN语言，早期非常普及的BASIC语言，第一个用严
格的文法描述的ALGOL60语言，便于编写结构化程序的Pascal 语言以及本书讲述的C语言都是
高级语言。

问题6:什么是面向过程语言?
高级语言又可分为面向过程语言和面向问题语言两类。面向过程语言虽然可以独立于计算机
编写程序，但用这类语言编写程序时，程序要非常详细地告诉计算机如何做，程序需要详细描述
解题的过程和细节。C语言就是一种面向过程的语言。例如，在某个职工数据文件中查找工号为
22650的职工，面向过程语言需要详细描述查找过程。以下算法是适应面向过程语言的一个查找
过程的描述。
①打开职工文件。
②当文件未结束时重复执行以下工作：
a.读取文件的当前记录。
b.如果当前记录中的工号是22650,则结束步骤②。
③ 关闭职工文件。
④ 如果找到，则返回找到的职工信息，否则返回找不到的标志信息。
其中，步骤②是一个循环控制结构，控制记录一个一个地读取和比较。
问题7:什么是面向问题语言?
面向问题语言通常是指在特定应用领域中使用的高级语言。人们使用面向问题语言时，不要
详细给出问题的求解算法和求解过程，只须指出问题做什么、数据输入和输出形式，就能得到所
需的计算结果。实际上，计算机是根据预先的规定，执行先前准备好的程序，回答问题的结果。
面向问题语言又称非过程化语言或陈述性语言，如报表语言、SQL(Structured Query Language)等。
SQL是数据库查询语言，在数据库管理系统的支持下，用SQL提出的查询或操纵要求，就能由数
据库管理系统完成。使用面向问题语言解题时，只要告诉计算机做什么,不必告诉计算机如何做，
能方便用户使用和提高程序的开发速度。但实现面向问题语言的系统从最一般的意义下实现问题
如何做，通常实现的效率较低。另外，面向问题语言要求问题已有确定的求解方法，目前其应用
范围还比较狭窄。
如果用面向问题语言SQL描述问题6中所述的查找要求，只需要用一条能表达以下含义的简
单命令：从职工数据文件选取信息，条件是工号等于22650。
数据文件打开、用循环控制结构描述记录逐个地读取和比较，以及数据文件使用结束的关闭
等细节都不再详述。

问题8:什么是面向对象语言?
为克服面向过程语言过分强调求解过程的细节、程序不易复用等缺点，推出了面向对象程序
设计方法和面向对象程序设计语言。面向对象语言引入了对象、消息、类、继承、封装、抽象、
多态性等概念和机制。用面向对象语言进行程序设计时，以问题域中的对象为基础，将具有类似
性质的对象抽象成类，并利用继承机制，仅对差异进行程序设计。对于大型程序，面向对象语言
能提高程序的开发效率、提高程序的可靠性及可维护性等。

<p>
***
<p>

|进制	  |前缀	   |示例	  |对应的十进制值|
|---------|--------|----------|---------|
|二进制   |0b 或 0B|	0b1010|	 10     |
|八进制   |0       |	012   |   10    |
|十进制	  |无	   |    10	  |   10    |
|十六进制 |0x 或 0X|   0xA    |	   10   |
<p>

***

<p>

>左值：特定的有地址的变量<br>
>右值：右值通常是“临时”的、没有名字的、即将被销毁的值，我们不能对它取地址。<br>




<a>https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170<br>
参见↑<br>
运算符优先级指定了包含多个运算符的表达式中的运算顺序。 <br>
运算符关联性指定了在包含多个具有相同优先级的运算符的表达式中，操作数是与其左侧还是右侧的操作数组合。<br>


后缀递增与后缀递减属于第2组优先级，从左到右关联<br>
前缀递增与前缀递减属于第3组优先级，从右到左关联<br>

\* / % 属于第5组优先级；+ - 属于第6组优先级，皆为从左到右关联<br>


a\*a++ 先执行（a++）语句返回4，但将a左值递增至5；再执行\*，得到 5*4=20<br>
c=++a+a 先执行（++a）语句，a左值递增至6，并返回6，再执行+，得到6+6=12<br>
<p>

***


```
printf("%c对应的ASCLL码为%d\n",ch,ch);
```
<p>
//%d对应数字,%c输出对应字符，<br>
// %c,%d类似于占位符，提前说明这里如何输出并从后找
<p>

***
```
    float n,m;
    int _n,_m;
    _n=(int)n; _m=(int)m;
```
<p>
类型转化
(int)(x)
<p>

***

计算机的进制主要包括：二进制（binary）、八进制（octal）、十进制（decimal）和十六进制（hexadecimal）。<br>
```
    printf(" 十进制 %d 对应的八进制数是:%o\n",x,x);
    printf(" 十进制 %d 对应的十六进制数是:%x\n",x,x);
```


%+5d右对齐的方式输出5个字符宽度，不足五位前补空格(当5改成2时，仍然会输出正常的168)<br>
%-5d左对齐的方式输出5个字符宽度，不足五位后补空格<br>
%+6.2f输出6个字符宽度（其中2位小数）实际上，正负号占字符宽度，当6改为1后也会正常输出整数部分<br>
%E输出科学计数法<br>

注：scanf("%*d",&k);//读完之后不花内存地址去读

```
    int a=168;
    float b=123.456;
    float x=35.567,y;
/*
%5d右对齐的方式输出5个字符宽度，不足五位前补空格(当5改成2时，仍然会输出正常的168)
%-5d左对齐的方式输出5个字符宽度，不足五位后补空格
%+6.2f输出6个字符宽度（其中2位小数）实际上，正负号占字符宽度，当6改为1后也会正常输出整数部分
%E输出科学计数法
*/
    printf(" a = %5d\n",a);
    printf(" a = %-5d\n",a);
    printf(" b = %6.2f\n",b);//%.2f形式控制小数精度
    printf(" b = %E\n",b);
    y=(int)(x*100+0.5)/100.0;
    printf(" y = %f\n",y);
```


***
```
    int x;double y;
    x=y=3.5;
```
    最终x=3,y=3.5
    自动取整，过程中按照最牛逼的搞
    

***

>if( 语句1&& 语句2)//如果语句1是假，那么语句2就会不执行（不管里头都有什么）<br>

逗号运算<p>
```
int y=7,float z=4;
x=(y=y+6,y/z);
//结果x=3
//按最后的运算结果进行运算
```
***

运算过程中
char->int
float->double

运算对象不同类时，short $\rhd$ unsigned $\rhd$ long $\rhd$ float

***
```
#include<stdio.h>
int main()
{
    int i;char c;long k;float f;double x;
//    i=2,c='B',k=123456,f=5.8,x=3.4;
/*
input：
i=2 c=B
k=123456
f=5.8 x=3.4
*/
    scanf("i=%d c=%c",&i,&c);
    getchar();
    scanf("k=%ld",&k);
    getchar();
    scanf("f=%f x=%lf",&f,&x);
    printf("i=%d c=%c k=%ld f=%f x=%lf",i,c,k,f,x);
    return 0;
}
```
>scanf为格式化输入，会按照双引号内的格式去匹配输入的字符串。<br>
它不在意"i=%d c=%c"间的空格数量，但很在意其他字符匹配，以及两个scanf间是否有空格。
从本质上讲，我们从键盘输入的数据并没有直接交给 scanf()，而是放入了缓冲区中，直到
我们按下回车键（输入换行符），scanf() 才到缓冲区中读取数据。
如果缓冲区中的数据符合 scanf() 的要求，那么就读取结束；
如果不符合要求，那么就继续等待用户输入，或者干脆读取失败。
所以这里要用getchar()读掉换行符/空格

***

```
#include<stdio.h>
int main()
{
    int a=8,b=9;float x=127.895,y=-123.456;char c='B';long n=12345678L; unsigned u=65535u;
    printf("%f,%f\n",x,y);//输出float x y
    printf("%-12f,%-12f\n",x,y);//左对齐  共宽12
    //由于二进制小数精度问题，所以有误差
    //127.894997  ,-123.456001
     printf("%8.3f,%8.3f,%.3f,%.3f,%4f,%5f\n",x,y,x,y,x,y);//  负号占用一格
     127.895,-123.456,127.895,-123.456,127.894997,-123.456001
    printf("%s,%6.3s,%-10.5s\n","c language","c language","c language");//%s输出字符串，%s6表示总宽，.3是取前3个字符
//c language,   c l,c lan
    return 0;
}

```
>基本的，正整数对应右对齐，负整数对应左对齐，数字大小为输出宽度。<br>
值得注意的是，小数都是二进制小数表示，所以除非明确精度或者恰好比较好表示，则都会出现“≠”的情况。<br>
另外，字符串.x类似于“取小数”，即取前x个字符。

***
自顶向下，逐步细化<br>
模块化编程<br>

-不能互相耦合，

结构化编码<br>


***
exit app级的退出

***
c++数据和它的属性打包了，想怎么写怎么写<br>
c语言：数据属性/变量要在一开头就全定义完毕（早期？）
```
//必须定义在作用域开头：在C89/C90标准中，变量必须在代码块（如函数、循环、条件语句）的开头定义。例如：

void example() {
    int a = 10; // 正确：定义在函数开头
    printf("%d", a);
    // 错误：不能在语句后定义新变量
    printf("Hello");
    int b = 20; // 编译错误（C89/C90）
}
//历史原因：早期编译器设计简单，变量定义需集中处理内存分配。这种限制也源于C语言的“声明在前”传统（如函数原型需在调用前声明）。
```

***

switch接口加速？
执行列表
列表要跳？

```
swith(expression)
{
    case 常量表达式1:    [break];
    case 常量表达式2:    [break];
    [default: ;]
}
```
```
// switch_statement1.cpp
#include <stdio.h>

int main() {
   const char *buffer = "Any character stream";
   int uppercase_A, lowercase_a, other;
   char c;
   uppercase_A = lowercase_a = other = 0;

   while ( c = *buffer++ )   // Walks buffer until NULL
   {
      switch ( c )
      {
         case 'A':
            uppercase_A++;//不break，跳转，会继续执行下一个case，包括default
            break;
         case 'a':
            lowercase_a++;
            break;
         default:
            other++;
      }
   }
   printf_s( "\nUppercase A: %d\nLowercase a: %d\nTotal: %d\n",
      uppercase_A, lowercase_a, (uppercase_A + lowercase_a + other) );
}
```


数组
    }
看起来你想了解关于 printf("%*c") 的用法。这是C/C++中一个特殊的格式化输出方式。

printf("%*c", width, character) 中的 %*c 是一个格式说明符，它允许你通过参数动态指定字段宽度。

让我详细解释一下：

%*c 格式说明符
* 表示字段宽度将由参数指定
c 表示输出一个字符
第一个参数是宽度值（整数）
第二个参数是要输出的字符
示例代码
```
#include <stdio.h>

int main() {
    int j;
    scanf("%d", &j);
    for(int i=0;i<40;++i)printf("%d",i);
    printf("\n");
    // 输出字符 'A'，并指定字段宽度为10
    printf("%*c\n", 10, 'A');
    
    // 输出字符 'B'，并指定字段宽度为5
    printf("%*c\n", 5, 'B');
    
    // 输出字符 'X'，并指定字段宽度为1（实际上就是普通输出）
    printf("%*c\n", 1, 'X');
    printf("j=%5d\n",j);
/*
%*c 格式说明符：

%c 是输出单个字符的格式说明符
* 表示字段宽度由参数指定
所以 %*c 的含义是：输出一个字符，但该字符占据的宽度由参数指定

所以之后会增加一个参数
*/
    
//    printf("\nstart");
    printf("%*c",j,' ');
    printf("end");
    return 0;
}

```

***

让我来解释一下你提出的两个问题：

##### 1. 为什么 `sizeof(s)` 总是输出 8？

`sizeof(s)` 返回的是 `std::string` 对象本身的大小，而不是字符串内容的长度。在大多数现代系统上，`std::string` 对象内部通常包含以下成员：

- 指向实际字符串数据的指针 (通常占 8 字节，在64位系统上)
- 字符串长度信息
- 字符串容量信息

所以 `sizeof(s)` 返回的是这个 string 对象结构体的大小，通常是 8 字节（在64位系统上）或 4 字节（在32位系统上），与实际存储的字符串内容长度无关。

如果你想要获取字符串的实际长度，应该使用 `s.length()` 或 `s.size()` 方法：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    cin >> s;
    cout << "sizeof(s) = " << sizeof(s) << endl;     // string对象的大小，通常是8
    cout << "s.length() = " << s.length() << endl;   // 字符串内容的实际长度
    return 0;
}
```

##### 2. `printf` 中的 `0.2` 是什么含义？

在格式化字符串 `"%0.2f"` 中：
- `0` 表示用0来填充字段宽度（如果不指定，则默认用空格填充）
- `.2` 表示小数点后保留2位小数
- [f](file://d:\FDU_1\CS10004%20Programming\ppt\程序设计2025_作业说明.pdf) 表示这是一个浮点数

所以 `%0.2f` 的意思是：输出一个浮点数，保留2位小数，不足的位数用0填充。

但要注意，在你的例子中，格式是 `"%0.2f"`，但没有指定总宽度，所以 `0` 实际上没有效果。如果你想要看到用0填充的效果，需要指定总宽度，比如 `"%08.2f"`：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    float f = 12.3f;
    printf("默认格式: %.2f\n", f);       // 输出: 12.30
    printf("0填充格式: %08.2f\n", f);    // 输出: 00012.30
    printf("空格填充格式: %8.2f\n", f);  // 输出:    12.30 (前面有空格)
    return 0;
}
```

在你的代码中，`%0.2f` 实际上等同于 `%.2f`，都是保留两位小数的意思。


***
***
for顶测试<br>
do while底测试<br>

exit(0)
$\leftrightarrow$
exit(EXIT_SUCCESS)

***
构造数据类型：
数组，指针，结构，联合

***
面向对象是解释性的，可以临时定义变量分配内存 <br>
面向过程，整个函数是一个对象，必须要在开头把变量定义以分配内存<br>

***
<p>常量存储空间永远不会被更改<p>


***
int i=1;
printf("%d %d,++i,--i)是什么东西,执行顺序？

看编译器

***

*与&究竟是什么


***

<p>
关于数组大小和 '\0' 终止符
你问到两个重要问题：

为什么数组大小没有填？

这是C/C++的特性：当你用字符串字面量初始化字符数组时，编译器会自动计算所需的数组大小
这样做既方便又安全，避免了手动计算可能出现的错误
最后一个元素会是 '\0' 吗？

是的，当你用双引号括起来的字符串字面量初始化字符数组时，编译器会自动在末尾添加 '\0' 终止符
所以 char str[] = "hello world"; 实际存储的是 {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\0'}
这使得该数组可以被所有期望以 '\0' 结尾的C风格字符串函数正确处理，如 strlen(), strcpy() 等
<p>


***
EOF  endofile
是个字符
while(getchar()!=EOF)
读一个字符，如果读到文件末尾，则返回EOF
ctrl+z 结束


***
转向语句是编程语言中直接改变程序执行顺序的结构化指令，主要通过选择结构和循环结构实现流程控制。在C 等现代编程语言中，if-else语句通过条件表达式实现程序分支跳转，switch-case语句配合break命令完成多分支转向。循环结构中的continue与break语句可分别实现循环体内部跳转和循环终止 [1

转向语句非常的慢
比较符本质还是运算，顺序运行也很快


***

c++并行计算？？

线程互相独立 沟通起来很困难
进程