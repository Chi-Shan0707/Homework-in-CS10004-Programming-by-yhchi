<p>

|进制	  |前缀	   |示例	  |对应的十进制值|
|---------|--------|----------|---------|
|二进制   |0b 或 0B|	0b1010|	 10     |
|八进制   |0       |	012   |   10    |
|十进制	  |无	   |    10	  |   10    |
|十六进制 |0x 或 0X|   0xA    |	   10   |
<p>

***

<p>

>左值：特定的有地址的变量<br>
>右值：右值通常是“临时”的、没有名字的、即将被销毁的值，我们不能对它取地址。<br>




<a>https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170<br>
参见↑<br>
运算符优先级指定了包含多个运算符的表达式中的运算顺序。 <br>
运算符关联性指定了在包含多个具有相同优先级的运算符的表达式中，操作数是与其左侧还是右侧的操作数组合。<br>


后缀递增与后缀递减属于第2组优先级，从左到右关联<br>
前缀递增与前缀递减属于第3组优先级，从右到左关联<br>

\* / % 属于第5组优先级；+ - 属于第6组优先级，皆为从左到右关联<br>


a\*a++ 先执行（a++）语句返回4，但将a左值递增至5；再执行\*，得到 5*4=20<br>
c=++a+a 先执行（++a）语句，a左值递增至6，并返回6，再执行+，得到6+6=12<br>
<p>

***


```
printf("%c对应的ASCLL码为%d\n",ch,ch);
```
<p>
//%d对应数字,%c输出对应字符，<br>
// %c,%d类似于占位符，提前说明这里如何输出并从后找
<p>

***
```
    float n,m;
    int _n,_m;
    _n=(int)n; _m=(int)m;
```
<p>
类型转化
(int)(x)
<p>

***

计算机的进制主要包括：二进制（binary）、八进制（octal）、十进制（decimal）和十六进制（hexadecimal）。<br>
```
    printf(" 十进制 %d 对应的八进制数是:%o\n",x,x);
    printf(" 十进制 %d 对应的十六进制数是:%x\n",x,x);
```


%+5d右对齐的方式输出5个字符宽度，不足五位前补空格(当5改成2时，仍然会输出正常的168)<br>
%-5d左对齐的方式输出5个字符宽度，不足五位后补空格<br>
%+6.2f输出6个字符宽度（其中2位小数）实际上，正负号占字符宽度，当6改为1后也会正常输出整数部分<br>
%E输出科学计数法<br>

注：scanf("%*d",&k);//读完之后不花内存地址去读

```
    int a=168;
    float b=123.456;
    float x=35.567,y;
/*
%5d右对齐的方式输出5个字符宽度，不足五位前补空格(当5改成2时，仍然会输出正常的168)
%-5d左对齐的方式输出5个字符宽度，不足五位后补空格
%+6.2f输出6个字符宽度（其中2位小数）实际上，正负号占字符宽度，当6改为1后也会正常输出整数部分
%E输出科学计数法
*/
    printf(" a = %5d\n",a);
    printf(" a = %-5d\n",a);
    printf(" b = %6.2f\n",b);//%.2f形式控制小数精度
    printf(" b = %E\n",b);
    y=(int)(x*100+0.5)/100.0;
    printf(" y = %f\n",y);
```


***
```
    int x;double y;
    x=y=3.5;
```
    最终x=3,y=3.5
    自动取整，过程中按照最牛逼的搞
    

***

>if( 语句1&& 语句2)//如果语句1是假，那么语句2就会不执行（不管里头都有什么）<br>

逗号运算<p>
```
int y=7,float z=4;
x=(y=y+6,y/z);
//结果x=3
//按最后的运算结果进行运算
```
***

运算过程中
char->int
float->double

运算对象不同类时，short $\rhd$ unsigned $\rhd$ long $\rhd$ float

***
```
#include<stdio.h>
int main()
{
    int i;char c;long k;float f;double x;
//    i=2,c='B',k=123456,f=5.8,x=3.4;
/*
input：
i=2 c=B
k=123456
f=5.8 x=3.4
*/
    scanf("i=%d c=%c",&i,&c);
    getchar();
    scanf("k=%ld",&k);
    getchar();
    scanf("f=%f x=%lf",&f,&x);
    printf("i=%d c=%c k=%ld f=%f x=%lf",i,c,k,f,x);
    return 0;
}
```
>scanf为格式化输入，会按照双引号内的格式去匹配输入的字符串。<br>
它不在意"i=%d c=%c"间的空格数量，但很在意其他字符匹配，以及两个scanf间是否有空格。
从本质上讲，我们从键盘输入的数据并没有直接交给 scanf()，而是放入了缓冲区中，直到
我们按下回车键（输入换行符），scanf() 才到缓冲区中读取数据。
如果缓冲区中的数据符合 scanf() 的要求，那么就读取结束；
如果不符合要求，那么就继续等待用户输入，或者干脆读取失败。
所以这里要用getchar()读掉换行符/空格

***

```
#include<stdio.h>
int main()
{
    int a=8,b=9;float x=127.895,y=-123.456;char c='B';long n=12345678L; unsigned u=65535u;
    printf("%f,%f\n",x,y);//输出float x y
    printf("%-12f,%-12f\n",x,y);//左对齐  共宽12
    //由于二进制小数精度问题，所以有误差
    //127.894997  ,-123.456001
     printf("%8.3f,%8.3f,%.3f,%.3f,%4f,%5f\n",x,y,x,y,x,y);//  负号占用一格
     127.895,-123.456,127.895,-123.456,127.894997,-123.456001
    printf("%s,%6.3s,%-10.5s\n","c language","c language","c language");//%s输出字符串，%s6表示总宽，.3是取前3个字符
//c language,   c l,c lan
    return 0;
}

```
>基本的，正整数对应右对齐，负整数对应左对齐，数字大小为输出宽度。<br>
值得注意的是，小数都是二进制小数表示，所以除非明确精度或者恰好比较好表示，则都会出现“≠”的情况。<br>
另外，字符串.x类似于“取小数”，即取前x个字符。

