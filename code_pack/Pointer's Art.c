#include <stdio.h>
int a[10]; 
//(1)长度为10的整型数组
int b[][3] = {{1, 0, 0}, {4, 2, 0}}; 
//(2)每行3列的二维整型数组
int *p[2]; 
//(3)存int*指针的数组（2个element)
int (*q)[3]=b; 
/*
----------------------------------------------
## 二维数组b[n][3]中第i行b[i]
---------------------------------------------
*/
int (*u)(int, int); 
//(5)函数指针,指向参数为(int,int)返回int的函数
int *v(int, int); 
//(6)声明返回 int*的函数
int *(*w)(int, int); 
//(7)指向返回int*的函数的函数指针
int main()
{
    return 0;
}
/*
9.试指出以下代码的意义：
(1)int a[10];
(2)int b[][3]={(1},,,(4,2}};
(3)int *p[];
(4)int(*q)[];
(5)int(*u)(int,int);
(6)int*v(int,int);
(7)int*(*w)(int,int);
*/
/*
int (*q)[3]=b; 

----------------------------------------------
## 二维数组b[n][3]中第i行b[i]
---------------------------------------------

好问题。结论先说：
- C 的二维数组在内存里是连续的“行优先”存储，但类型信息（每行列数）仍然重要，影响指针运算与索引。

关于 `q` 和访问方式
- 正确写法：`int b[N][3]; int (*q)[3] = b;`
  - `q` 指向整行，`q+i == &b[i]`，访问用 `q[i][j]`（等价 `b[i][j]`）。
- 你说的“`(*q) = b`”不成立：`*q` 的类型是 `int[3]`（数组），数组是不可赋值对象，不能被赋值；应写 `q = b`。
- 也可以线性访问：`int *p = &b[0][0];` 然后 `p[i*3 + j]`；但此时不可写 `p[i][j]`，因为 `p` 是 `int*` 不是“指向含3个int的数组的指针”。

为什么不能省略列数
- 编译器做 `q+1` 需要知道跳过一整行的大小（`3*sizeof(int)`）。少了 `[3]`（不完整类型）就无法做行级指针运算与 `q[i][j]`。

函数参数的正确姿势
- 固定列：`void f(int a[][3]) 
{ 
 }` 等价 `void f(int (*a)[3])`。
- 运行期列数（VLA）：`void g(int n, int m, int a[n][m])`，此时 `a` 等价 `int (*a)[m]`，必须先有 `m`。

小例
- 行指针：`int (*q)[3] = b; printf("%d\n", q[1][2]); // b[1][2]`
- 线性：`int *p = &b[0][0]; printf("%d\n", p[1*3 + 2]); // b[1][2]`

需要的话，我可以在 T1.c 加一段小演示对比两种访问方式。
*/