# 期中考试复习笔记

## 考试范围
- 期中考试内容覆盖到数组部分
- 需要熟练掌握课本知识
- 考试难度约等于3次作业的难度

## 编程范式

### 命令式编程
- 大部分指令已经预先编写好
- 按部就班地进行编译执行
- 函数只是不同参数的传递
- 模板（如 `template<class>`）看似传递类型，但后续的 `typeT` 等都已经预先定义好

### 函数式编程
- 函数是第一等公民
- 举例：鼠标在不同应用程序中的行为不同
  - 在绘图软件中可能是画笔
  - 在游戏中可能是准星
  - 左右键功能各不相同
- 核心思想：将整个鼠标函数作为主体在各个应用程序中传递，应用程序如何使用这些函数不再需要关心

## 编程语言发展

### (1) 机器语言
- 计算机的指令系统
- 所有计算机只能直接执行机器语言编写的程序
- 指令用二进制代码表示（0和1）
- 每条指令完成最基本操作
  - 例：从内存读取数据到寄存器
  - 例：寄存器内容相加
  - 例：将寄存器内容存入内存

### (2) 汇编语言
- 用助记符号代替二进制代码
- 例：`LD GR0,X`（从变量X对应的内存取数到寄存器GR0）
- 例：`ADD GR0,GR1`（GR1内容与GR0相加，结果存于GR0）
- 需要汇编器将汇编语言转换为机器语言

### (3) 高级语言
- 主要由语句构成，有统一语法规则
- 独立于具体机器，便于编码和阅读
- 需要编译器转换为机器语言
- 例子：FORTRAN、BASIC、ALGOL60、Pascal、C语言

## 高级语言分类

### 面向过程语言
- 需要详细描述解题过程和细节
- 例：在职工文件中查找工号为22650的职工
  ```plaintext
  ① 打开职工文件
  ② 当文件未结束时重复：
     a. 读取当前记录
     b. 如果工号是22650，结束循环
  ③ 关闭文件
  ④ 返回结果
  ```
- C语言是面向过程语言

### 面向问题语言（非过程化语言）
- 只需指出要做什么，不必描述如何做
- 例：SQL查询 `从职工数据文件选取信息，条件是工号等于22650`
- 优点：方便使用，开发速度快
- 缺点：实现效率较低，应用范围较窄

### 面向对象语言
- 引入对象、消息、类、继承、封装、抽象、多态等概念
- 以问题域中的对象为基础
- 提高程序开发效率、可靠性和可维护性

## 进制表示

| 进制     | 前缀      | 示例      | 对应的十进制值 |
|----------|-----------|-----------|----------------|
| 二进制   | 0b 或 0B  | 0b1010    | 10             |
| 八进制   | 0         | 012       | 10             |
| 十进制   | 无        | 10        | 10             |
| 十六进制 | 0x 或 0X  | 0xA       | 10             |

## 左值与右值

- **左值**：特定的有地址的变量
- **右值**：通常是临时的、没有名字的、即将被销毁的值，不能对其取地址

## 运算符优先级

参考：[Microsoft C++ 运算符优先级文档](https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170)

- **运算符优先级**：指定包含多个运算符的表达式中的运算顺序
- **运算符关联性**：指定相同优先级运算符的操作数组合方向

### 重要优先级组别
- **第2组**：后缀递增与后缀递减，从左到右关联
- **第3组**：前缀递增与前缀递减，从右到左关联  
- **第5组**：`* / %`，从左到右关联
- **第6组**：`+ -`，从左到右关联

### 示例分析
```c
a*a++   // 先执行(a++)返回4，但a递增至5；再执行*，得到5*4=20
c=++a+a // 先执行(++a)，a递增至6并返回6；再执行+，得到6+6=12
```

## 格式化输出

```c
printf("%c对应的ASCII码为%d\n", ch, ch);
```
- `%d` 对应数字
- `%c` 输出对应字符
- 格式说明符类似于占位符，从参数列表中按顺序取值

## 类型转换

```c
float n, m;
int _n, _m;
_n = (int)n;
_m = (int)m;
```
- 使用 `(类型)(表达式)` 进行强制类型转换

## 进制输出

```c
printf("十进制 %d 对应的八进制数是:%o\n", x, x);
printf("十进制 %d 对应的十六进制数是:%x\n", x, x);
```

## 格式化控制

```c
int a = 168;
float b = 123.456;
float x = 35.567, y;

printf("a = %5d\n", a);      // 右对齐，5字符宽度，不足补空格
printf("a = %-5d\n", a);     // 左对齐，5字符宽度，不足补空格  
printf("b = %6.2f\n", b);    // 6字符宽度，2位小数
printf("b = %E\n", b);       // 科学计数法输出

y = (int)(x*100 + 0.5)/100.0;  // 四舍五入到两位小数
printf("y = %f\n", y);
```

**注意**：当宽度指定过小时，仍会输出完整的数值。

## 输入输出注意事项

```c
scanf("%*d", &k);  // 读入数据但不存储到内存地址
```

## 赋值运算

```c
int x; double y;
x = y = 3.5;
```
- 最终结果：`x = 3`, `y = 3.5`
- 自动取整，运算过程按照最高精度进行

## 逻辑运算优化

```c
if(语句1 && 语句2)  // 如果语句1为假，语句2不会执行
```

## 逗号运算

```c
int y = 7;
float z = 4;
x = (y = y + 6, y/z);  // 结果x=3，按最后一个表达式结果计算
```

## 类型转换规则

运算过程中的自动类型转换：
- `char` → `int`
- `float` → `double`

不同类运算对象的转换顺序：
`short` → `unsigned` → `long` → `float`

## 格式化输入

```c
#include<stdio.h>
int main()
{
    int i; char c; long k; float f; double x;
    
    scanf("i=%d c=%c", &i, &c);
    getchar();  // 读取换行符
    scanf("k=%ld", &k);
    getchar();  // 读取换行符  
    scanf("f=%f x=%lf", &f, &x);
    
    printf("i=%d c=%c k=%ld f=%f x=%lf", i, c, k, f, x);
    return 0;
}
```

**重要说明**：
- `scanf` 按照双引号内的格式匹配输入字符串
- 不在意格式字符串中的空格数量，但很在意其他字符匹配
- 输入数据先放入缓冲区，按回车后 `scanf` 才读取
- 需要使用 `getchar()` 读取换行符/空格

## 格式化输出示例

```c
#include<stdio.h>
int main()
{
    int a = 8, b = 9;
    float x = 127.895, y = -123.456;
    char c = 'B';
    long n = 12345678L;
    unsigned u = 65535u;
    
    printf("%f,%f\n", x, y);                    // 输出float x y
    printf("%-12f,%-12f\n", x, y);              // 左对齐，共宽12
    
    // 由于二进制小数精度问题，会有误差
    // 127.894997, -123.456001
    
    printf("%8.3f,%8.3f,%.3f,%.3f,%4f,%5f\n", x, y, x, y, x, y);
    // 127.895,-123.456,127.895,-123.456,127.894997,-123.456001
    // 负号占用一格
    
    printf("%s,%6.3s,%-10.5s\n", "c language", "c language", "c language");
    // %s输出字符串，%6.3s总宽6取前3字符，%-10.5s左对齐总宽10取前5字符
    // 输出: c language,   c l,c lan
    
    return 0;
}
```

**格式化规则**：
- 正整数对应右对齐，负整数对应左对齐，数字大小为输出宽度
- 二进制小数表示可能导致精度误差
- 字符串中的 `.x` 表示取前x个字符

## 编程方法论

- **自顶向下，逐步细化**
- **模块化编程**：模块之间不能互相耦合
- **结构化编码**

## 程序控制

- `exit()`：应用程序级别的退出

## C与C++比较

- **C++**：数据和属性打包，灵活性高
- **C语言**：数据属性/变量必须在作用域开头定义（早期标准）

```c
// C89/C90标准要求变量必须在代码块开头定义
void example() {
    int a = 10;  // 正确：定义在函数开头
    printf("%d", a);
    
    // 错误：不能在语句后定义新变量（C89/C90）
    printf("Hello");
    int b = 20;  // 编译错误
}
```

**历史原因**：早期编译器设计简单，需要集中处理内存分配。

## Switch语句

```c
switch(expression) {
    case 常量表达式1: [break;]
    case 常量表达式2: [break;]
    [default: ;]
}
```

**执行特点**：
- 提供快速的跳转表执行
- 如果没有 `break`，会继续执行后续case，包括default

```c
// switch示例：统计字符流中'A'、'a'和其他字符的数量
#include <stdio.h>

int main() {
    const char *buffer = "Any character stream";
    int uppercase_A, lowercase_a, other;
    char c;
    uppercase_A = lowercase_a = other = 0;

    while (c = *buffer++) {  // 遍历buffer直到NULL
        switch (c) {
            case 'A':
                uppercase_A++;  // 没有break会继续执行下一个case
                break;
            case 'a':
                lowercase_a++;
                break;
            default:
                other++;
        }
    }
    printf("\nUppercase A: %d\nLowercase a: %d\nTotal: %d\n",
           uppercase_A, lowercase_a, (uppercase_A + lowercase_a + other));
    return 0;
}
```

## 动态宽度格式化

`printf("%*c", width, character)` 说明：
- `%*c` 允许通过参数动态指定字段宽度
- `*` 表示字段宽度由参数指定
- `c` 表示输出一个字符
- 第一个参数是宽度值（整数）
- 第二个参数是要输出的字符

```c
#include <stdio.h>

int main() {
    int j;
    scanf("%d", &j);
    
    for(int i = 0; i < 40; ++i) printf("%d", i);
    printf("\n");
    
    printf("%*c\n", 10, 'A');  // 输出字符'A'，宽度为10
    printf("%*c\n", 5, 'B');   // 输出字符'B'，宽度为5
    printf("%*c\n", 1, 'X');   // 输出字符'X'，宽度为1
    
    printf("j=%5d\n", j);
    printf("%*c", j, ' ');     // 输出j个空格
    printf("end");
    
    return 0;
}
```

## 字符串长度与对象大小

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    cin >> s;
    cout << "sizeof(s) = " << sizeof(s) << endl;    // string对象本身的大小（通常是8）
    cout << "s.length() = " << s.length() << endl;  // 字符串内容的实际长度
    return 0;
}
```

**重要区别**：
- `sizeof(s)` 返回 `std::string` 对象本身的大小
- `s.length()` 返回字符串内容的实际长度

## 浮点数格式化

```c
#include <bits/stdc++.h>
using namespace std;

int main() {
    float f = 12.3f;
    printf("默认格式: %.2f\n", f);       // 输出: 12.30
    printf("0填充格式: %08.2f\n", f);    // 输出: 00012.30
    printf("空格填充格式: %8.2f\n", f);  // 输出:    12.30（前面有空格）
    return 0;
}
```

**格式说明**：
- `%0.2f` 中的 `0` 表示用0填充（需要指定宽度才有效）
- `.2` 表示保留2位小数
- `f` 表示浮点数

## 循环结构

- **for循环**：顶测试循环
- **do-while循环**：底测试循环

## 程序退出

```c
exit(0) ↔ exit(EXIT_SUCCESS)  // 两者等价
```

## 数据类型分类

**构造数据类型**：
- 数组
- 指针  
- 结构
- 联合

## 编程范式内存管理

- **面向对象**：解释性的，可以临时定义变量分配内存
- **面向过程**：整个函数是一个对象，必须在开头定义变量以分配内存

## 常量

常量存储空间永远不会被更改。

## 表达式求值顺序

```c
int i = 1;
printf("%d %d", ++i, --i);  // 执行顺序取决于编译器
```

## 指针基础

`*` 与 `&` 操作符：
- `*`：解引用操作符，获取指针指向的值
- `&`：取地址操作符，获取变量的内存地址


## 字符串存入字符数组
```
char str[]="hello world";

//最后会存入一位'\0'
```
<p>
char str[]="hello world";这句话什么意思，c中会怎么理解 c++会怎么理解  为什么数组大小没有填 最后一个元素会是'\0‘吗
<p>
<p>
关于数组大小和 '\0' 终止符
你问到两个重要问题：

为什么数组大小没有填？

这是C/C++的特性：当你用字符串字面量初始化字符数组时，编译器会自动计算所需的数组大小
这样做既方便又安全，避免了手动计算可能出现的错误
最后一个元素会是 '\0' 吗？

是的，当你用双引号括起来的字符串字面量初始化字符数组时，编译器会自动在末尾添加 '\0' 终止符
所以 char str[] = "hello world"; 实际存储的是 {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\0'}
这使得该数组可以被所有期望以 '\0' 结尾的C风格字符串函数正确处理，如 strlen(), strcpy() 等
<p>