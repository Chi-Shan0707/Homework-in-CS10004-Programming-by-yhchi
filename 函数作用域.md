<p>
11.试分别指出以下数据对象的存储类别。<br>
(1)x是函数的整型形参。<br>
(2)y是某函数专用，并能保留函数前次调用结果的变量。<br>(3)z只能让同一源程序文件中的函数共享的变量。<br>
(4)d是能让程序中许多函数共享的变量。
<p>

```
static y;
//程序头部的静态变量，只能在本程序内【任意地方】被访问，不可被外部访问，作用域也在这个文件【内部】
extern z;
//程序头部的外部存储变量，可在多个文件当中通过extern共享引用，
//但是这里的z需要在别的地方不加【extern】被正式定义一下
void fo(int x)/*x是局部变量，是auto int作用域仅限于函数内部，生命周期从函数调用开始到函数结束。每次调用函数时，形参都会重新分配存储空间。*/
{
  static y;
//y是局部静态变量，在整个程序期间存储位置不会变化，不会随函数结束而销毁，但作用域仅限于函数内部
}
```


***

<br>


### C语言数据对象的存储类别分析

在C语言中，数据对象的存储类别（storage class）决定了变量的生命周期（lifetime）、作用域（scope）和链接（linkage）。常见的存储类别包括 `auto`、`register`、`static` 和 `extern`。下面分别分析题中各数据对象的存储类别，并给出简要理由。

#### (1) x是函数的整型形参
- **存储类别**：`auto`（自动存储类别）。
- **理由**：函数形参默认具有 `auto` 存储类别。它是局部变量，作用域限于函数内部，生命周期从函数调用开始到函数结束。每次调用函数时，形参都会重新分配存储空间。

#### (2) y是某函数专用，并能保留函数前次调用结果的变量
- **存储类别**：`static`（静态存储类别）。
- **理由**：这描述了局部静态变量（local static variable）。`static` 局部变量的作用域限于函数内部，但生命周期是整个程序运行期间。它在函数首次调用时初始化一次，并在后续调用中保留上一次的值，不会随函数结束而销毁。

#### (3) z只能让同一源程序文件中的函数共享的变量
- **存储类别**：`static`（静态存储类别）。
- **理由**：这指的是文件作用域的静态变量（file-scope static variable）。在源文件顶部（函数外部）声明的 `static` 变量具有内部链接（internal linkage），只能在同一源文件中被函数访问，不能被其他源文件引用或共享。

#### (4) d是能让程序中许多函数共享的变量
- **存储类别**：`extern`（外部存储类别）。
- **理由**：这描述了全局变量（global variable）或外部变量，具有外部链接（external linkage）。在源文件顶部声明（不带 `static`）的变量可以在多个源文件中通过 `extern` 声明共享，被程序中的多个函数访问。它的生命周期是整个程序运行期间。

### 补充说明
- **存储类别关键字**：`auto` 和 `register` 用于局部变量（函数内），`static` 用于局部或全局（文件作用域），`extern` 用于全局（跨文件）。
- **默认行为**：局部变量默认 `auto`，全局变量默认 `extern`（外部链接）。
- **示例代码片段**（假设在同一文件中）：
  ```c
  #include <stdio.h>

  // (4) d: extern (全局变量，可跨文件共享)
  int d = 10;  // 或在其他文件用 extern int d; 声明

  // (3) z: static (文件作用域，只能本文件共享)
  static int z = 20;

  void func() {
      // (1) x: auto (形参，默认自动)
      int x;  // 假设 x 是形参，这里模拟局部变量

      // (2) y: static (局部静态，保留值)
      static int y = 0;
      y++;
      printf("x(auto): %d, y(static): %d, z(static): %d, d(extern): %d\n", x, y, z, d);
  }

  int main() {
      func();
      func();  // y 会保留上一次的值
      return 0;
  }
  ```
- 如果你需要更详细的代码示例、编译运行演示，或针对特定编译器的差异，请提供更多上下文！
*/